<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Class 12: Divide and Conquer II</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/elevate-section-attrs-2.0/elevate-section-attrs.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">



<div class="wrapper">

<!-- Sidebar Holder -->
<nav id="sidebar">
<div class="sidebar-header">
  <h3 style="text-align: left;">
    <a style="text-decoration: none;"href="./index.html">
      Competitive programming UTEC
    </a>
  </h3>
  <strong>
    <a style="text-decoration: none;"href="./index.html">
    CP-UTEC
    </a>
  </strong>
</div>

<div id="dismiss-left">
  <i class="fa fa-arrow-left"></i>
</div>

<div id="dismiss-right">
  <i class="fa fa-arrow-right"></i>
</div>

<ul class="list-unstyled components">

  <div class="line"></div>
  
  <li id="index-page">
    <a href="./index.html">
      Home
    </a>
  </li>

  <div class="line"></div>

  <li id="schedule-page">
    <a href="./schedule.html">
      Schedule
    </a>
  </li>

  <div class="line"></div>

  <li id="classes-page-expanded">
    <a id="classes" href="#all-classes" data-toggle="collapse"
      aria-expanded="false">
      Classes
    </a>
    <ul class="collapse list-unstyled" id="all-classes">
      <li id="class-01">
        <a href="./class-01.html">1. Introduction</a>
      </li>
      <li id="class-02">
        <a href="./class-02.html">2. Asymptotic Analysis</a>
      </li>
      <li id="class-03">
        <a href="./class-03.html">3. Standard Template Library</a>
      </li>
      <li id="class-04">
        <a href="./class-04.html">4. Complete Search I</a>
      </li>
      <li id="class-05">
        <a href="./class-05.html">5. Complete Search II</a>
      </li>
      <li id="class-06">
        <a href="./class-06.html">6. Complete Search III</a>
      </li>
      <li id="class-07">
        <a href="./class-07.html">7. Complete Search IV</a>
      </li>
      <li id="class-08">
        <a href="./class-08.html">8. Complete Search V</a>
      </li>
      <li id="class-09">
        <a href="./class-09.html">9. Contest I</a>
      </li>
      <li id="class-10">
        <a href="./class-10.html">10. Contest UTEC-UNI-UPC I</a>
      </li>
      <li id="class-11">
        <a href="./class-11.html">11. Divide and Conquer I</a>
      </li>
      <li id="class-12">
        <a href="./class-12.html">12. Divide and Conquer II</a>
      </li>
      <li id="class-13">
        <a href="./class-13.html">13. Game Theory I</a>
      </li>
      <li id="class-14">
        <a href="./class-14.html">14. Game Theory II</a>
      </li>

    </ul>
  </li>

  <div class="line"></div>

  <li id="classes-page-not-expanded">
    <a href="./classes.html">
      Classes
    </a>
  </li>

  <div class="line"></div>

  <li id="daily-problem-page">
    <a href="./daily-problem.html">
      Daily problem
    </a>
  </li>

  <div class="line"></div>

  <li id="gallery-page">
    <a href="./gallery.html">
      Gallery
    </a>
  </li>

  <div class="line"></div>

</ul>


<!--
<ul class="list-unstyled">
  <li>
    <a href="https://www.utec.edu.pe/" target="_blank" class="logo">
      <img src="images/page/utec-logo.png" alt="UTEC logo">
    </a>
  </li>
</ul>
-->
</nav>

<div id="expand-icon-right">
  <i class="fa fa-angle-right"></i>
</div>

<div id="expand-icon-left">
  <i class="fa fa-angle-left"></i>
</div>

<!-- Page Content Holder -->
<div id="content">
<script>
$(".main-container")
  .removeClass("main-container")
  .removeClass("container-fluid")
</script>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Class 12: Divide and Conquer II</h1>
<h4 class="date">02-19-2020</h4>

</div>


<blockquote>
<p>“Don’t Repeat Yourself”</p>
</blockquote>
<div class="topic">
Generalized binary search
</div>
<p>When we are doing binary search we are basically finding a function <span class="math inline">\(f: \mathbb{D} \to \{0, 1\}\)</span>, we are finding a function that maps the elements of a set <span class="math inline">\(\mathbb{D}\)</span> to <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> (can be seen as false or true respectively) and <span class="math inline">\(f\)</span> <strong>is always a monotone</strong> function (non-increasing or non-decreasing).</p>
<p>For example, if we have the array <span class="math inline">\(A = \{b_0, b_1, b_2, \dots, b_{n - 1}\}\)</span> and we are going to do queries over the array to determine whether a number is in <span class="math inline">\(A\)</span> or not we can do these definitions:</p>
<p><span class="math display">\[\mathbb{D} = \{0, 1, 2, \dots, n\}\]</span> <span class="math display">\[f_p(x) = [p \leq A[x]]\]</span></p>
<p>That is, <span class="math inline">\(f = f_p\)</span> will be a function that will indicate if <span class="math inline">\(p \leq A[x]\)</span> for <span class="math inline">\(x \in [0, n)\)</span> and as <span class="math inline">\(f\)</span> must be monotone we need to sort <span class="math inline">\(A\)</span> (<strong>why?</strong>). Now, with these definitions and asumming <span class="math inline">\(A\)</span> is sorted, <span class="math inline">\(f\)</span> may looks something like this.</p>
<div class="row text-center">
<p><img src="images/class-12/monotone-function.png" /></p>
</div>
<p>Then, if <span class="math inline">\(p\)</span> is in the array <span class="math inline">\(A\)</span>, it must hold that <span class="math inline">\(A[z] = p\)</span>, so now our problem is to find the first element where <span class="math inline">\(f(x) = 1\)</span>, that is <span class="math inline">\(z\)</span> and we can compute it using divide and conquer.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

// Returns true if p is in A in O(n)
bool brute_force (const vector &lt;int&gt;&amp; A, int p) {
  for (int elem: A) {
    if (elem == p) return true;
  }
  return false;
}

// Returns true if p is in A in O(log n)
bool divide_and_conquer (const vector &lt;int&gt;&amp; A, int p) {
  int l = 0, r = A.size() - 1;
  while (l != r) {
    int m = (l + r) &gt;&gt; 1; // = (l + r) / 2
    bool f_p = (p &lt;= A[m]);
    if (f_p) {
      r = m;
    } else {
      l = m + 1;
    }
  }
  int z = l;
  return (A[z] == p);
}

int main () {
  // To get &#39;good&#39; random numbers
  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  // Create A with n random values
  int n = 1000;
  int min_value = -1e6;
  int max_value = 1e6;
  vector &lt;int&gt; A(n);
  for (int&amp; elem: A) {
    elem = uniform_int_distribution &lt;int&gt; (min_value, max_value)(rng);
  }
  sort(begin(A), end(A));
  // Check q queries
  int q = 1000;
  for (int i = 0; i &lt; q; i++) {
    int p = uniform_int_distribution &lt;int&gt; (min_value, max_value)(rng);
    bool ret1 = brute_force(A, p);
    bool ret2 = divide_and_conquer(A, p);
    if (ret1 != ret2) {
      cout &lt;&lt; &quot;Something is wrong!\n&quot;;
      return (-1);
    }
  }
  cout &lt;&lt; &quot;OK!\n&quot;;
  return (0);
}</code></pre>
<p>What would have changed if <span class="math inline">\(f_p(x) = [A[x] \leq p]\)</span> ?</p>
<p>The idea of defining the set <span class="math inline">\(\mathbb{D}\)</span> and the <strong>mononote</strong> function <span class="math inline">\(f\)</span> can be used in a great variety of problem. For example in <a href="https://codeforces.com/contest/1201/problem/C">this problem</a>.</p>
<p>Here let <span class="math inline">\(median\)</span> be the median of the original array, then we know that the maximum median we can get must in in <span class="math inline">\([median, median + k]\)</span>, so <span class="math inline">\(\mathbb{D} = [median, median + k]\)</span> and let <span class="math inline">\(f\)</span> be defined like this:</p>
<p><span class="math inline">\(f(x) = [\)</span> can we obtain median x in at most k operations? <span class="math inline">\(]\)</span></p>
<p>Let <span class="math inline">\(y\)</span> be the position of the median, then if we have:</p>
<p><span class="math display">\[a_0, a_1, a_2, \dots, a_y, a_{y + 1}, \dots, a_{n - 1}\]</span></p>
<p>And we want <span class="math inline">\(x\)</span> as the new median in the minimum number of operations, then we need to make <span class="math inline">\(x \leq a_i, \forall \, y \leq i \leq n\)</span>. (<strong>why?</strong>). Moreover there is a point <span class="math inline">\(z\)</span> such that:</p>
<p><span class="math display">\[f(i) = 1 \quad \forall i \in [median, z]\]</span> <span class="math display">\[f(i) = 0 \quad \forall i \in [z + 1, median + 1]\]</span></p>
<p>So <span class="math inline">\(f\)</span> is monotone and our answer is <span class="math inline">\(z\)</span>. The we can implement the following solution:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int main () {
  int n, k;
  cin &gt;&gt; n &gt;&gt; k;
  vector &lt;int&gt; a(n);
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
  sort(begin(a), end(a));
  int y = n / 2;
  ll median = a[y];
  ll l = median, r = median + k;
  while (l != r) {
    ll m = (l + r + 1) / 2;
    ll n_operations = 0;
    for (int i = y; i &lt; n; i++) {
      if (a[i] &lt; m) {
        n_operations += m - a[i];
      }
    }
    if (l &lt; 0) break;
    if (n_operations &lt;= k) {
      l = m;
    } else {
      r = m - 1;
    }
  }
  int z = l;
  cout &lt;&lt; z &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
<p>In these examples we have defined <span class="math inline">\(\mathbb{D} \subset \mathbb{Z}\)</span> but we may have, for example, <span class="math inline">\(\mathbb{D} \subset \mathbb{R}\)</span>.</p>
<p>Moreover, if you have problems determining how to compute <span class="math inline">\(m\)</span>, always think of what do you want to do when <span class="math inline">\(l + 1 = r\)</span>. You want that <span class="math inline">\(m = l \lor m = r\)</span> and then you will find if you need to compute <span class="math inline">\(m = (l + r) / 2\)</span> or <span class="math inline">\(l = (l + r + 1) / 2\)</span> and how to update <span class="math inline">\(l, r\)</span>.</p>
<div class="topic">
Ternary search
</div>
<p>Let <span class="math inline">\(f(x)\)</span> be a unimodal function in <span class="math inline">\([l, r]\)</span>, that is, it holds</p>
<ul>
<li>The function stricly increases first, reaches a maximum (at a single point or over an interval) and then stricly decreases.</li>
</ul>
<p>Or</p>
<ul>
<li>The function stricly decreases first, reaches a minimum (at a single point or over an interval) and then stricly increases.</li>
</ul>
<p>Then, assuming the first scenario (the second one is analogous), how can we find the maximum value of <span class="math inline">\(f(x) \mid x \in [l, r]\)</span> ?</p>
<p>For simplicity, let <span class="math inline">\([l, r] \subset \mathbb{R}\)</span>.</p>
<p>Let <span class="math inline">\(l \leq m_1 \leq m_2 \leq r\)</span></p>
<p>Initially you know that the maximum is in <span class="math inline">\([l, r]\)</span> and by the trichotomy property there are three cases:</p>
<ul>
<li><span class="math inline">\(f(m_1) = f(m_2)\)</span>. Then we are done</li>
<li><span class="math inline">\(f(m_1) &lt; f(m_2)\)</span>. Then the answer must be in <span class="math inline">\([m_1, r]\)</span> (<strong>why?</strong>).</li>
<li><span class="math inline">\(f(m_1) &gt; f(m_2)\)</span>. Then the answer must be in <span class="math inline">\([l, m_2]\)</span> (<strong>why?</strong>).</li>
</ul>
<p>So, each time we can reduce the interval where the answer must be. In we split the interval <span class="math inline">\([l, r]\)</span> in three parts, then we will find the answer in <span class="math inline">\(O(\log n)\)</span> and we may have:</p>
<p><span class="math display">\[m_1 = \frac{2 \cdot l + r}{3}\]</span> <span class="math display">\[m_2 = \frac{l + 2 \cdot r}{3}\]</span></p>
<p>Try solving the problem at the end of <a href="https://www.hackerearth.com/practice/algorithms/searching/ternary-search/tutorial/">this tutorial</a> to apply what we have learned.</p>
<p>The idea also works when <span class="math inline">\([l, r] \subset \mathbb{Z}\)</span> with some little modifications.</p>
<p>So far we have study binary and ternary search, yet the D&amp;C paradigm does not reduce only to this. Next, we will show two more scenarios where D&amp;C paradigm comes in handy.</p>
<div class="topic">
Merge sort
</div>
<div id="subproblem-merge-two-sorted-arrays" class="section level3">
<h3>Subproblem: merge two sorted arrays</h3>
<p>Let</p>
<p><span class="math display">\[a = [a_1, a_2, \dots, a_n]\]</span> <span class="math display">\[b = [b_1, b_2, \dots, b_m]\]</span></p>
<p>be two sorted arrays. How can we get a sorted array with the elements of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> ?</p>
<p>The most naive approach would be to create an array with its elements and sort it, something like this:</p>
<pre class="cpp"><code>vector &lt;int&gt; c;
for (int elem: a) c.push_back(elem);
for (int elem: b) c.push_back(elem);
sort(begin(c), end(c));</code></pre>
<p>But, this solution is <span class="math inline">\(O((n + m) \log (n + m))\)</span> and we are not using the fact that both arrays are sorted. But, we can notice that as both array are sorted, the minimum element of <span class="math inline">\(c\)</span> must be <span class="math inline">\(a_1\)</span> or <span class="math inline">\(b_1\)</span>. Next, out next minimum element must be in <span class="math inline">\((a[2:n], b[1:m])\)</span> or in <span class="math inline">\((a[1:n], b[2:m])\)</span>. That is, we can iterate both arrays in such a way the we are always getting the next minimum element of <span class="math inline">\(c\)</span>, therefore we can get <span class="math inline">\(c\)</span> sorted in <span class="math inline">\(O(n + m)\)</span> in this way:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

// To get &#39;good&#39; random numbers
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int min_value = -1e6;
int max_value = 1e6;

// return a random integer in [l, r]
int random (int l, int r) {
  return uniform_int_distribution &lt;int&gt; (l, r)(rng);
}

vector &lt;int&gt; get_random_array (int n) {
  vector &lt;int&gt; ret(n);
  for (int&amp; elem: ret) {
    elem = random(min_value, max_value);
  }
  return ret;
}

vector &lt;int&gt; merge (const vector &lt;int&gt;&amp; a, const vector &lt;int&gt;&amp; b) {
  const int INF = INT_MAX;
  vector &lt;int&gt; A = a;
  vector &lt;int&gt; B = b;
  int n = A.size();
  int m = B.size();
  // to simplify the implementation
  A.push_back(INF);
  B.push_back(INF);
  int it1 = 0, it2 = 0;
  vector &lt;int&gt; c;
  while (it1 &lt; n or it2 &lt; m) {
    if (A[it1] &lt;= B[it2]) {
      c.push_back(A[it1]);
      it1++;
    } else {
      c.push_back(B[it2]);
      it2++;
    }
  }
  return c;
}

int main () {
  for (int test = 0; test &lt; 1000; test++) {
    int n = random(1, 1000);
    int m = random(1, 1000);
    vector &lt;int&gt; a = get_random_array(n);
    sort(begin(a), end(a));
    vector &lt;int&gt; b = get_random_array(m);
    sort(begin(b), end(b));
    // naive merge
    vector &lt;int&gt; c;
    for (int elem: a) c.push_back(elem);
    for (int elem: b) c.push_back(elem);
    sort(begin(c), end(c));
    if (c != merge(a, b)) {
      cout &lt;&lt; &quot;Something is wrong!\n&quot;;
      return (-1);
    }
  }
  cout &lt;&lt; &quot;OK!\n&quot;;
  return (0);
}</code></pre>
</div>
<div id="merge-sort" class="section level3">
<h3>Merge sort</h3>
<p>The idea of merge sort is very simple:</p>
<p>Let <code>vector &lt;int&gt; merge_sort(vector &lt;int&gt;&amp; a)</code> be a function that returns the array <code>a</code> sorted, then we can define it recursively, we can split the array <code>a</code> in two disjoint arrays (the optimal is to split it in the middle), sort each new array and then merge then efficiently using the function of the previous subsection. We can implement it in this way:</p>
<pre class="cpp"><code>...
vector &lt;int&gt; merge_sort (const vector &lt;int&gt;&amp; a) {
  if (a.size() &lt;= 1) return a;
  int m = a.size() / 2;
  vector &lt;int&gt; left;
  for (int i = 0; i &lt; m; i++) left.push_back(a[i]);
  vector &lt;int&gt; right;
  for (int i = m; i &lt; a.size(); i++) right.push_back(a[i]);
  vector &lt;int&gt; x = merge_sort(left);
  vector &lt;int&gt; y = merge_sort(right);
  return merge(x, y);
};
...</code></pre>
<p><a href="./code/class-12/merge-sort.cpp">Full code</a></p>
<p>And we can also implement merge sort in a simple way using the STL in this way:</p>
<pre class="cpp"><code>vector &lt;int&gt; merge_sort (const vector &lt;int&gt;&amp; a) {
  if (a.size() &lt;= 1) return a;
  int m = a.size() / 2;
  vector &lt;int&gt; left(begin(a), begin(a) + m);
  vector &lt;int&gt; right(begin(a) + m, end(a));
  vector &lt;int&gt; x = merge_sort(left);
  vector &lt;int&gt; y = merge_sort(right);
  vector &lt;int&gt; ret;
  std::merge(begin(x), end(x),
             begin(y), end(y),
             std::back_inserter(ret));
  return ret;
};</code></pre>
<p><a href="./code/class-12/merge-sort-stl.cpp">Full code</a></p>
<p><strong>Can we improve the above implementation?</strong></p>
<p>Now, in order to get the complexity of this algorithm notice that</p>
<ul>
<li>We need to run <span class="math inline">\(2^0\)</span> merge function in <span class="math inline">\(O(n / 2^0)\)</span></li>
<li>We need to run <span class="math inline">\(2^1\)</span> merge functions in <span class="math inline">\(O(n / 2^1)\)</span></li>
<li>We need to run <span class="math inline">\(2^2\)</span> merge functions in <span class="math inline">\(O(n / 2^2)\)</span></li>
<li>We need to run <span class="math inline">\(2^4\)</span> merge functions in <span class="math inline">\(O(n / 2^3)\)</span> …</li>
<li>We need to run <span class="math inline">\(2^{\log n}\)</span> merge functions in <span class="math inline">\(O(n / 2^{\log n})\)</span></li>
</ul>
<p>We can see it in this way:</p>
<div class="row text-center">
<p><img src="images/class-12/merge-sort.png" /></p>
</div>
<p>So, basically, the number of operations that merge sort does (i.e its complexity) is the area of a rectangle with width <span class="math inline">\(O(n)\)</span> and height <span class="math inline">\(O(\log n)\)</span>, then the complexity of merge sort is <span class="math inline">\(O(n \log n)\)</span>.</p>
<div class="topic">
Inductive constructions
</div>
<p>In some mathematical induction proofs we use disjoint smaller cases of a problem to solve a larger one (usually doing some kind of constructions). For example:</p>
<p><strong>Problem:</strong> In a square grid of side length <span class="math inline">\(2^n\)</span>, one unit square is blocked (represented by coloring it black). Your task is to cover the remaining <span class="math inline">\(4^n - 1\)</span> squares with <em>triominos</em>, L-shaped tiles consisting of three squares in the following fashion. The triominos can be rotated by any multiple of <span class="math inline">\(90\)</span> degrees. Moreover, the triominos may not overlap each other, nor cover anything outside the grid. Given <span class="math inline">\(1 \leq n \leq 8, 0 \leq x &lt; 2^n \land  0 \leq y &lt; 2^n\)</span>. The black square has coordinates <span class="math inline">\((x, y)\)</span>. Find a valid tiling of the grid.</p>
<p>These are the four valid rotations of a triomino.</p>
<div class="row text-center img-border">
<p><img src="images/class-12/tiling1.png" /></p>
</div>
<p>This is a possible tiling for <span class="math inline">\(n = 2\)</span>.</p>
<div class="row text-center img-border">
<p><img src="images/class-12/tiling2.png" /></p>
</div>
<ul>
<li>The problem and images where taken from <a href="https://www.csc.kth.se/~jsannemo/slask/main.pdf">Principles of Algorithmic Problem Solving, secion 10.1 - page 170</a>.</li>
</ul>
<p>First of all let’s prove that there is always a valid tiling by induction:</p>
<ul>
<li><p>If <span class="math inline">\(n = 1\)</span> no matter where that black square is, we can always fill the grid with one of the valid rotations of a triomino.</p></li>
<li><p>If <span class="math inline">\(n &gt; 1\)</span> we can divide the grid in four grids of size <span class="math inline">\(2^{n - 1}\)</span>, we can identify in which new grid the black square is and put a triomino in such a way that it have 1 of its square in one different grid and is not in the grid where the black square is. Then, we have to solve the same problem in four smaller instances, but by the inductive hyphotesis we already have the answer for them. This construction idea can be seen in this image:</p>
<div class="row text-center">
<p><img src="images/class-12/triomino.png" /></p>
</div></li>
</ul>
<p>And we can use the construction used in the above proof to implement a solution like this:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int TOP_LEFT = 0;
const int TOP_RIGHT = 1;
const int BOTTON_LEFT = 2;
const int BOTTON_RIGHT = 3;

struct Rectangle {
  int x, y;
  int len;
  pair &lt;int, int&gt; new_black;
  Rectangle () {}
  Rectangle (int x, int y, int len, int position):
    x(x), y(y), len(len) {
    switch (position) {
      case TOP_LEFT:
        new_black = {x, y}; 
        break;
      case TOP_RIGHT:
        new_black = {x, y + len - 1};
        break;
      case BOTTON_LEFT:
        new_black = {x + len - 1, y};
        break;
      case BOTTON_RIGHT:
        new_black = {x + len - 1, y + len - 1};
        break;
      default:
        break;
    }
    
  }
  bool has (pair &lt;int, int&gt; black) {
    return x &lt;= black.first and black.first &lt; x + len and
           y &lt;= black.second and black.second &lt; y + len;
  }
};

char cur_letter = &#39;a&#39;;

void update_cur_letter () {
  if (cur_letter == &#39;z&#39;) cur_letter = &#39;a&#39;;
  else cur_letter++;
}

void solve (Rectangle rect, pair &lt;int, int&gt; black, vector &lt;string&gt;&amp; grid) {
  if (rect.len == 1) return;
  vector &lt;Rectangle&gt; sector;
  int m = rect.len / 2;
  int x = rect.x;
  int y = rect.y;
  sector.emplace_back(x + 0, y + 0, m, BOTTON_RIGHT);
  sector.emplace_back(x + 0, y + m, m, BOTTON_LEFT);
  sector.emplace_back(x + m, y + 0, m, TOP_RIGHT);
  sector.emplace_back(x + m, y + m, m, TOP_LEFT);
  char ch = cur_letter;
  update_cur_letter();
  for (auto s: sector) {
    if (s.has(black)) {
      solve(s, black, grid);
    } else {
      grid[s.new_black.first][s.new_black.second] = ch;
      solve(s, s.new_black, grid);
    }
  }
}

int main () {
  int n, x, y;
  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
  assert (1 &lt;= n and n &lt; 8);
  int m = (1 &lt;&lt; n);
  assert (0 &lt;= x &lt; m);
  assert (0 &lt;= y &lt; m);
  vector &lt;string&gt; grid(m, string(m, &#39; &#39;));
  grid[x][y] = &#39;#&#39;;
  solve(Rectangle(0, 0, m, -1), pair &lt;int, int&gt;(x, y), grid);
  for (string&amp; row: grid) cout &lt;&lt; row &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
<p>Recommended readings:</p>
<ul>
<li><a href="https://www.csc.kth.se/~jsannemo/slask/main.pdf">Principles of Algorithmic Problem Solving, section 10.1 and 10.2</a></li>
<li><a href="https://cp-algorithms.com/num_methods/ternary_search.html">E-maxx - Ternary search</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/searching/linear-search/tutorial/">HackerEarth - Searching [Tutorial]</a></li>
<li><a href="https://nbviewer.jupyter.org/github/TISparta/pcuni-2019/blob/master/clase-16/clase-16.ipynb">PCUNI-2019 clase 16</a></li>
<li><a href="https://www.topcoder.com/binary-stride-a-variant-on-binary-search/">Topcoder - Binary stride a variant on binary search</a></li>
</ul>
<div id="contest" class="topic">
Contest
</div>
<p>You can find the contest <a href="https://vjudge.net/contest/359160">here</a>.</p>
<p>The solutions will be uploaded after the contest.</p>
<p style="float: none; clear: both;">
</p>
<div class="pt-3" style="float: right;">
<p><a class="continue-link" href="./class-13.html" 
     data-toggle="tooltip" title="Game Theory I"> Next </a></p>
</div>
<div class="pt-3">
<p><a class="continue-link" href="./class-11.html"
     data-toggle="tooltip" title="Divide and Conquer I"> Previous </a></p>
</div>
<script>
  $('#all-classes').collapse('show');
  $('#class-12').addClass('active');
  const cur_class = document.getElementById('class-12');
  cur_class.scrollIntoView({
    behavior: 'smooth',
    block: 'center'
  });
</script>
</div>

</div> <!-- ends wrapper -->
</div> <!-- ends content -->

<script type="text/javascript">

$(document).ready(function () {
  $('#dismiss-left').on('click', function () {
    $('#sidebar, #content').addClass('active');
  });

  $('#dismiss-right').on('click', function () {
    $('#sidebar, #content').removeClass('active');
  });

  $("[data-toggle='tooltip']").tooltip();

  $('#expand-icon-right').on('click', function () {
    document.getElementById('sidebar').style.width = "90px";
    document.getElementById('expand-icon-right').style.display = "none";
    document.getElementById('expand-icon-left').style.display = "block";
    document.getElementById('content').style.background = "rgba(0,0,0,0.8)";
    $('#expand-icon-left').addClass('moved');
    $('#expand-icon-right').addClass('moved');
  });

  $('#expand-icon-left').on('click', function () {
    document.getElementById('sidebar').style.width = "0px";
    document.getElementById('expand-icon-right').style.display = "block";
    document.getElementById('expand-icon-left').style.display = "none";
    document.getElementById('content').style.background = "#fafafa";
    $('#expand-icon-left').removeClass('moved');
    $('#expand-icon-right').removeClass('moved');
  });

});

/*
$(window).scroll(function() { 
  $('#expand-icon-left').css({top: '50vh'});
  $('#expand-icon-left').css({bottom: '50vh'});
  $('#expand-icon-right').css({top: '50vh'});
  $('#expand-icon-right').css({bottom: '50vh'});
});
*/
</script>

<!--
<footer>
  <p>Copyright &copy; 2020. Competitive Programming UTEC</p>
</footer>
-->



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
