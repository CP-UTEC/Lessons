<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Class 11: Divide and Conquer I</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/elevate-section-attrs-2.0/elevate-section-attrs.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CP UTEC</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="schedule.html">Schedule</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lessons
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 1</li>
    <li>
      <a href="class-01.html">Introduction</a>
    </li>
    <li>
      <a href="class-02.html">Asymptotic Analysis</a>
    </li>
    <li class="dropdown-header">Week 2</li>
    <li>
      <a href="class-03.html">STL</a>
    </li>
    <li>
      <a href="class-04.html">Complete Search I</a>
    </li>
    <li class="dropdown-header">Week 3</li>
    <li>
      <a href="class-05.html">Complete Search II</a>
    </li>
    <li>
      <a href="class-06.html">Complete Search III</a>
    </li>
    <li class="dropdown-header">Week 4</li>
    <li>
      <a href="class-07.html">Complete Search IV</a>
    </li>
    <li>
      <a href="class-08.html">Complete Search V</a>
    </li>
    <li class="dropdown-header">Week 5</li>
    <li>
      <a href="class-09.html">Contest I</a>
    </li>
    <li class="dropdown-header">Week 6</li>
    <li>
      <a href="class-10.html">Contest UTEC-UNI I</a>
    </li>
    <li class="dropdown-header">Week 7</li>
    <li>
      <a href="class-11.html">Divide and Conquer I</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="daily-problem.html">Daily Problem</a>
</li>
<li>
  <a href="gallery.html">Gallery</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Class 11: Divide and Conquer I</h1>
<h4 class="date">02-12-2020</h4>

</div>


<blockquote>
<p>“Binary like Yin &amp; Yang”</p>
</blockquote>
<div class="topic">
The Divide and Conquer Paradigm
</div>
<p>The main idea of <em>Divide and Conquer</em> is that we can tackle a big problem by solving smaller sub-problems and then merging this solutions together to get an answer. The genius part about all of this is that if we can find sub-problems that are similar to the original problem, then we can also use divide and conquer to solve the smaller problems.</p>
<p>There are usually three steps in divide and conquer:</p>
<ul>
<li>Divide: Forming the sub-problems.</li>
<li>Conquer: Solving each sub-problem.</li>
<li>Merge: Using the solutions to sub-problems to solve the original problem.</li>
</ul>
<p>Today we will learn about one of the most popular Divide and Conquer algorithms: <strong>Binary Search</strong>.</p>
<div class="topic">
Motivation
</div>
<p>Let’s say that you need to find the position of a value in an array. <strong>How would you do it?</strong></p>
<p>The most intuitive way of approaching this problem is to go through all elements in an array and check if it is the one you are looking for.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main () {
  int num = 10;
  int x=20;
  int arr[]={2,4,6,7,8,10,20,4034,4535,5635435,577436536};
  for (int i = 0; i &lt; 10; i++) {
    if (arr[i] == x) {
      cout &lt;&lt; i+1 &lt;&lt; endl;
      break;
    }
  }
  if (i==10) {
    cout&lt;&lt;x&lt;&lt;&quot; is not in the array&quot;&lt;&lt;endl;
  }
    
  return (0);
}</code></pre>
<p>It is very simple to see that this approach has a complexity of <span class="math inline">\(O(n)\)</span>. In general, this complexity is pretty good, however looking for a specific element in an array is a basic operation that usually needs to be done more than once. What happens if we do this linear search thousands of times? How many times can we do it without exceeding the time limit? <strong>Is there a better way?</strong></p>
<div class="topic">
Binary Search
</div>
<p>There is a better way and it’s called <em>Binary Search</em>. This is one of the most basic and powerful concepts, as it can be used in thousands of algorithms to boost up the performance significantly. Most importantly, as we will see, its uses go beyond searching for an element in an array. The only condition that needs to hold for binary search to work is that the array (or our search domain) must be sorted.</p>
<ul>
<li><strong>Divide:</strong> We can compare our value to the element in the middle of the array. As the array is sorted this will tell us if the element is to the right or the left of the middle.</li>
<li><strong>Conquer:</strong> We can now search for the element in the corresponding half of the array.</li>
<li><strong>Merge:</strong> If we find the element in its corresponding half we have also found it in the array.</li>
</ul>
<p>First Approach</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int binary_search(int *seq,int size, int x){
  int left = 0;
  right = size - 1;
  while (left &lt;= right) {
    int med = left + (right-left) / 2;
    if (arr[med] == x) {
      return seq;
    }
    else if (arr[med] &gt; x) {
      right = med - 1;
    }
    else {
      left = med+1;
    }
  }
  return -1;
}</code></pre>
<p>Now, what happen if there exists many equal values in the array. What position does the binary method return?</p>
<pre class="cpp"><code>  int arr[] = {2,4,6,7,8,10,10,10,20,4034,4535,5635435,577436536};</code></pre>
<p>In this cases we need more information in order to determine what value we must return. Even though in many problems it doesn’t matter which we pick, in many others it will. For that cases, we are going to work with lower and upper bound.</p>
<p><strong>Lower Bound</strong></p>
<p>The <em>lower bound</em> is the first element that does not compare less than the value we are looking for. In simpler words, is the first occurrence of the search value. The following is a possible implementation of lower bound, however, <code>std::lower_bound</code> can simplify things for us.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;,
int binary_search(int *arr, int size, int x) {
  int left = 0;
  int right = size - 1;
  int pos = -1;
  while (left &lt; right) {
    int med = left + (right - left) / 2;
    if (arr[med] == x) {
      pos = med;
    }
    if (arr[med] &gt;= x) {
      right = med;
    }
    else {
      left = med + 1;
    }
  }
  return pos;
}</code></pre>
<p><strong>Upper Bound</strong></p>
<p>This is the last element that compares less than or equal to our value. Similarly, it can be found using the following algorithm:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int binary_search(int *arr, int size, int x){
  int left = 0;
  int right = size - 1;
  int pos = -1;
  while (left &lt; right) {
    int med = left + (right - left + 1) / 2;
    if (arr[med] == x) {
      pos = med;
    }
    if (arr[med] &gt;= x) {
      right = med - 1;
    }
    else {
      left = med;
    }
  }
  return pos;
}</code></pre>
<div class="topic">
Away form Arrays
</div>
<p>As it was mentioned before, binary search is not only useful for finding values in an array, but it also has other uses. In this section we will explore some of these.</p>
<div id="solving-an-equation" class="section level2">
<h2>Solving an Equation</h2>
<p>Let’s say we want to solve the equation: <span class="math inline">\(f(x) = ax^3 + bx^2 + cx + d = e\)</span>, where <span class="math inline">\(a, b, c, d, e &gt; 0\)</span>. The answer must be right to 4 decimal places. How can we do this efficiently? We can use binary search to solve this in <span class="math inline">\(O(logn)\)</span> time. The key idea is to realize that <span class="math inline">\(f\)</span> is a increasing function, and therefore <span class="math inline">\(x_a \leq x_b \rightarrow f(x_a) \leq f(x_b)\)</span>. Therefore we can run a binary search in <span class="math inline">\(x\)</span> in order to find the answer. However our binary search will be slightly different, as now we don’t need to find a precise answer, but one with a precision of 4 decimal places. This means that we want to find an x such that <span class="math inline">\(|e - f(x)| &gt; 0.0001\)</span>.</p>
</div>
<div id="searching-for-the-answer" class="section level2">
<h2>Searching for the Answer</h2>
<p>Let’s consider the following problem: <a href="https://onlinejudge.org/external/120/12032.pdf" class="uri">https://onlinejudge.org/external/120/12032.pdf</a></p>
<ul>
<li>What would be the brute force approach?</li>
<li>How can we improve this basic solution?</li>
</ul>
<p>The key thing is to realize that if we can reach the top with some an initial strength <span class="math inline">\(k_0\)</span>, then any initial strength <span class="math inline">\(k, k &gt; k_0\)</span> can also reach the top. Therefore we can use binary search to look for the minimum value of <span class="math inline">\(k\)</span> that reaches the top from 1 to <span class="math inline">\(r + 1\)</span>. As we can determine for a given <span class="math inline">\(k\)</span> if it is possible to reach the top, then this solution would have a complexity of <span class="math inline">\(O(nlog(r + 1))\)</span>.</p>
<div id="contest" class="topic">
Contest
</div>
<p>You can find the contest <a href="https://vjudge.net/contest/357719">here</a>.</p>
<p>The solutions will be uploaded after the contest.</p>
</div>

<footer>
  <p>Copyright &copy; 2020. Competitive Programming UTEC</p>
</footer>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
